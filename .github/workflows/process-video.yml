name: ğŸ¬ AI Video Processor

on:
  repository_dispatch:
    types: [process_video]

jobs:
  process-video:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    # é›†ä¸­ç®¡ç†æ‰€æœ‰ç’°å¢ƒè®Šæ•¸
    env:
      # Cloudflare R2 é…ç½®
      CF_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
      CF_R2_ACCESS_KEY: ${{ secrets.CF_R2_ACCESS_KEY }}
      CF_R2_SECRET_KEY: ${{ secrets.CF_R2_SECRET_KEY }}
      CF_R2_BUCKET: ${{ secrets.CF_R2_BUCKET }}
      CF_R2_PUBLIC_DOMAIN: ${{ secrets.CF_R2_PUBLIC_DOMAIN }}
      
      # AI å’Œå…¶ä»–æœå‹™
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      YOUTUBE_COOKIES: ${{ secrets.YOUTUBE_COOKIES }}
      
      # ä»»å‹™åƒæ•¸
      JOB_ID: ${{ github.event.client_payload.job_id }}
      VIDEO_URL: ${{ github.event.client_payload.url }}
      CALLBACK_URL: ${{ github.event.client_payload.callback_url }}
      PLATFORM: ${{ github.event.client_payload.platform }}
      USER_NAME: ${{ github.event.client_payload.user_info.user_name }}
      CHAT_ID: ${{ github.event.client_payload.user_info.chat_id }}
      
      # æ•ˆèƒ½å„ªåŒ–
      PYTHONUNBUFFERED: 1
      PIP_NO_CACHE_DIR: 1
      PIP_DISABLE_PIP_VERSION_CHECK: 1
      
      # é è¨­å€¼ï¼ˆå¯é€šé secrets è¦†è“‹ï¼‰
      DEFAULT_CHAT_ID: ${{ secrets.DEFAULT_CHAT_ID || 'system' }}
    
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            requirements.txt
            scripts/
          sparse-checkout-cone-mode: false

      - name: ğŸ Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
          cache-dependency-path: 'requirements.txt'

      - name: ğŸ“ Create requirements.txt if not exists
        run: |
          # å¦‚æœ repo ä¸­æ²’æœ‰ requirements.txtï¼Œå‰µå»ºä¸€å€‹
          if [ ! -f requirements.txt ]; then
            cat > requirements.txt << 'REQUIREMENTS'
          # Core dependencies
          yt-dlp==2024.11.18
          boto3==1.35.0
          requests==2.32.3
          openai==1.54.0
          tenacity==9.0.0
          
          # Optional dependencies for better performance
          certifi>=2024.0.0
          urllib3>=2.0.0,<3.0.0
          REQUIREMENTS
            echo "ğŸ“ Created requirements.txt"
          fi
          
          # é¡¯ç¤ºä¾è³´é …
          echo "ğŸ“¦ Dependencies to install:"
          cat requirements.txt

      - name: ğŸ“¦ Install Dependencies
        run: |
          python -m pip install --upgrade pip wheel setuptools
          pip install -r requirements.txt
          
          # å®‰è£ ffmpegï¼ˆå¦‚æœéœ€è¦è½‰ç¢¼ï¼‰
          if [ "${{ env.PLATFORM }}" = "bilibili" ] || [ "${{ env.PLATFORM }}" = "douyin" ]; then
            sudo apt-get update -qq
            sudo apt-get install -qq ffmpeg
          fi

      - name: ğŸ”‘ Setup YouTube Cookies
        if: env.YOUTUBE_COOKIES != '' && env.PLATFORM == 'youtube'
        run: echo "$YOUTUBE_COOKIES" > cookies.txt

      - name: ğŸ¬ Process Video with AI Analysis
        run: |
          # å¦‚æœ scripts/video_processor.py å­˜åœ¨ï¼Œä½¿ç”¨å®ƒ
          if [ -f scripts/video_processor.py ]; then
            echo "ğŸ Using scripts/video_processor.py"
            python scripts/video_processor.py
          else
            echo "ğŸ Using embedded Python script"
            python3 << 'EOF'
          import os
          import sys
          import requests
          import boto3
          import time
          import json
          import re
          import glob
          import subprocess
          import hashlib
          from datetime import datetime
          from concurrent.futures import ThreadPoolExecutor, as_completed
          from pathlib import Path
          from yt_dlp import YoutubeDL
          from tenacity import retry, stop_after_attempt, wait_exponential

          # è¨­å®šæ—¥èªŒæ ¼å¼
          import logging
          logging.basicConfig(
              level=logging.INFO,
              format='%(asctime)s - %(levelname)s - %(message)s',
              datefmt='%Y-%m-%d %H:%M:%S'
          )
          logger = logging.getLogger(__name__)

          class VideoProcessor:
              def __init__(self, config):
                  self.config = config
                  self.base_payload = self._create_base_payload()
                  self.start_time = time.time()
                  
              def _create_base_payload(self):
                  """å‰µå»ºåŸºæœ¬å›èª¿ payload"""
                  # ä½¿ç”¨ç’°å¢ƒè®Šæ•¸ä¸­çš„é è¨­å€¼ï¼Œè€Œéç¡¬ç·¨ç¢¼
                  default_chat_id = self.config.get('default_chat_id', 'system')
                  
                  return {
                      'job_id': self.config['job_id'],
                      'platform': self.config['platform'],
                      'video_url': self.config['video_url'],
                      'user_name': self.config['user_name'],
                      'chat_id': self.config['chat_id'] if self.config['chat_id'] != 'Unknown' else default_chat_id,
                      'callback_url': self.config['callback_url'],
                      'completion_time': datetime.now().isoformat(),
                  }

              @retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))
              def send_callback(self, payload):
                  """ç™¼é€å›èª¿é€šçŸ¥åˆ° n8nï¼Œå¸¶æŒ‡æ•¸é€€é¿é‡è©¦æ©Ÿåˆ¶"""
                  callback_url = payload.get('callback_url')
                  if not callback_url:
                      logger.info("ğŸ¤« No callback URL provided")
                      return True
                  
                  logger.info(f"ğŸ“¡ Sending callback to: {callback_url}")
                  
                  try:
                      # ç§»é™¤ callback_url å¾ payload ä¸­
                      send_payload = {k: v for k, v in payload.items() if k != 'callback_url'}
                      
                      # ç¢ºä¿å¿…è¦å­—æ®µå­˜åœ¨
                      if 'status' not in send_payload:
                          send_payload['status'] = 'completed'
                      
                      response = requests.post(
                          callback_url, 
                          json=send_payload, 
                          timeout=30,
                          headers={'Content-Type': 'application/json'}
                      )
                      response.raise_for_status()
                      logger.info(f"âœ… Callback sent successfully: {response.status_code}")
                      return True
                  except Exception as e:
                      logger.error(f"âŒ Callback failed: {e}")
                      raise

              def analyze_with_ai(self, video_title, video_description="", transcript=""):
                  """ä½¿ç”¨ AI åˆ†æå½±ç‰‡å…§å®¹"""
                  try:
                      openai_key = self.config.get('openai_api_key')
                      if not openai_key:
                          logger.info("ğŸ¤– No OpenAI API Key, using fallback analysis")
                          return self._get_fallback_analysis(video_title, transcript)
                      
                      import openai
                      client = openai.OpenAI(api_key=openai_key)
                      
                      # é™åˆ¶è¼¸å…¥é•·åº¦ä»¥ç¯€çœ token
                      description_limit = min(len(video_description), 500)
                      transcript_limit = min(len(transcript), 1500)
                      
                      analysis_prompt = f"""
                      åˆ†æä»¥ä¸‹å½±ç‰‡å…§å®¹ä¸¦ä»¥ JSON æ ¼å¼å›æ‡‰ï¼š
                      
                      æ¨™é¡Œ: {video_title}
                      æè¿°: {video_description[:description_limit]}
                      å­—å¹•æ‘˜è¦: {transcript[:transcript_limit]}
                      
                      è«‹æä¾›ï¼š
                      {{
                        "ai_keywords": "3-5å€‹é—œéµè©ï¼Œç”¨é€—è™Ÿåˆ†éš”",
                        "ai_sentiment": "positive/negative/neutral",
                        "ai_category": "entertainment/education/news/technology/music/sports/gaming/other",
                        "transcription_language": "ç¹é«”ä¸­æ–‡/ç°¡é«”ä¸­æ–‡/è‹±æ–‡/æ—¥æ–‡/éŸ“æ–‡/other",
                        "ai_summary": "50å­—ä»¥å…§çš„å…§å®¹æ‘˜è¦"
                      }}
                      """
                      
                      response = client.chat.completions.create(
                          model="gpt-3.5-turbo",
                          messages=[
                              {"role": "system", "content": "ä½ æ˜¯ä¸€å€‹å°ˆæ¥­çš„å½±ç‰‡å…§å®¹åˆ†æåŠ©æ‰‹ã€‚"},
                              {"role": "user", "content": analysis_prompt}
                          ],
                          max_tokens=300,
                          temperature=0.7,
                          response_format={"type": "json_object"}
                      )
                      
                      ai_result = json.loads(response.choices[0].message.content)
                      ai_result['word_count'] = len(transcript.split()) if transcript else 0
                      ai_result['analysis_timestamp'] = datetime.now().isoformat()
                      return ai_result
                      
                  except Exception as e:
                      logger.error(f"ğŸ¤– AI analysis failed: {e}")
                      return self._get_fallback_analysis(video_title, transcript)

              def _get_fallback_analysis(self, video_title, transcript):
                  """å‚™ç”¨åˆ†ææ–¹æ³•"""
                  # æå–æœ‰æ„ç¾©çš„é—œéµè©
                  words = re.findall(r'\b[a-zA-Z\u4e00-\u9fa5]{2,}\b', video_title)
                  keywords = ', '.join(words[:5]) if words else 'unknown'
                  
                  # ç°¡å–®çš„èªè¨€æª¢æ¸¬
                  if re.search(r'[\u4e00-\u9fa5]', transcript):
                      if re.search(r'[ç¹é«”å­—ç‰¹å¾µå­—å¦‚ï¼šé€™å€‹ç‚ºéº¼]', transcript):
                          language = 'ç¹é«”ä¸­æ–‡'
                      else:
                          language = 'ç°¡é«”ä¸­æ–‡'
                  elif re.search(r'[a-zA-Z]', transcript):
                      language = 'è‹±æ–‡'
                  else:
                      language = 'unknown'
                  
                  return {
                      'ai_keywords': keywords,
                      'ai_sentiment': 'neutral',
                      'ai_category': 'other',
                      'transcription_language': language,
                      'word_count': len(transcript.split()) if transcript else 0,
                      'ai_summary': f'å½±ç‰‡æ¨™é¡Œï¼š{video_title[:50]}',
                      'analysis_timestamp': datetime.now().isoformat()
                  }

              def get_optimal_format(self, info):
                  """æ ¹æ“šå¹³å°é¸æ“‡æœ€ä½³ä¸‹è¼‰æ ¼å¼"""
                  platform = self.config['platform']
                  
                  # å¹³å°ç‰¹å®šæ ¼å¼
                  platform_formats = {
                      'youtube': 'best[height<=720][ext=mp4]/best[ext=mp4]/best',
                      'bilibili': 'best[height<=1080][ext=mp4]/best[ext=mp4]/best',
                      'twitter': 'best[ext=mp4]/best',
                      'instagram': 'best[ext=mp4]/best',
                      'tiktok': 'best[ext=mp4]/best',
                      'douyin': 'best[ext=mp4]/best'
                  }
                  
                  return platform_formats.get(platform, 'best[ext=mp4]/best')

              def download_video(self):
                  """ä¸‹è¼‰å½±ç‰‡å’Œå­—å¹•"""
                  logger.info(f"ğŸ“¥ Downloading video from {self.config['platform']}...")
                  
                  ydl_opts = {
                      'format': self.get_optimal_format(None),
                      'outtmpl': f'{self.config["job_id"]}.%(ext)s',
                      'quiet': False,
                      'no_warnings': False,
                      'extract_flat': False,
                      'force_generic_extractor': False,
                      'concurrent_fragment_downloads': 5,
                      'buffer_size': 16384,
                      'http_chunk_size': 10485760,  # 10MB chunks
                  }
                  
                  # å­—å¹•è¨­å®š
                  if self.config['platform'] in ['youtube', 'bilibili']:
                      ydl_opts.update({
                          'writeautomaticsub': True,
                          'writesubtitles': True,
                          'subtitleslangs': ['zh-Hant', 'zh-Hans', 'zh', 'en', 'ja', 'ko'],
                          'subtitlesformat': 'vtt/srt/best',
                      })
                  
                  # Cookie è¨­å®š
                  if self.config['platform'] == 'youtube' and os.path.exists('cookies.txt'):
                      ydl_opts['cookiefile'] = 'cookies.txt'
                      logger.info("ğŸª Using YouTube cookies")
                  
                  # ç‰¹å®šå¹³å°è¨­å®š
                  if self.config['platform'] == 'bilibili':
                      ydl_opts['http_headers'] = {
                          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                          'Referer': 'https://www.bilibili.com'
                      }
                  
                  # åŸ·è¡Œä¸‹è¼‰
                  with YoutubeDL(ydl_opts) as ydl:
                      info = ydl.extract_info(self.config['video_url'], download=True)
                  
                  return info

              def process_video_file(self, filename, info):
                  """è™•ç†ä¸‹è¼‰çš„å½±ç‰‡æª”æ¡ˆ"""
                  file_size = os.path.getsize(filename)
                  
                  # æª¢æŸ¥æ˜¯å¦éœ€è¦è½‰ç¢¼
                  if file_size > 100 * 1024 * 1024:  # 100MB
                      logger.info(f"ğŸ”„ Compressing large video file ({file_size / 1024 / 1024:.1f}MB)...")
                      compressed_file = f"{self.config['job_id']}_compressed.mp4"
                      
                      # ä½¿ç”¨ ffmpeg å£“ç¸®
                      ffmpeg_cmd = [
                          'ffmpeg', '-i', filename,
                          '-c:v', 'libx264',
                          '-preset', 'fast',
                          '-crf', '28',
                          '-c:a', 'aac',
                          '-b:a', '128k',
                          '-movflags', '+faststart',
                          '-y', compressed_file
                      ]
                      
                      try:
                          subprocess.run(ffmpeg_cmd, check=True, capture_output=True)
                          os.remove(filename)
                          filename = compressed_file
                          file_size = os.path.getsize(filename)
                          logger.info(f"âœ… Compressed to {file_size / 1024 / 1024:.1f}MB")
                      except subprocess.CalledProcessError as e:
                          logger.warning(f"âš ï¸ Compression failed: {e}")
                  
                  return filename, file_size

              def process_subtitles(self):
                  """è™•ç†å­—å¹•æª”æ¡ˆ"""
                  transcript = ""
                  subtitle_files = glob.glob(f"{self.config['job_id']}*.vtt") + \
                                  glob.glob(f"{self.config['job_id']}*.srt")
                  
                  if subtitle_files:
                      logger.info(f"ğŸ“ Found {len(subtitle_files)} subtitle files")
                      
                      # é¸æ“‡æœ€ä½³å­—å¹•æª”æ¡ˆï¼ˆå„ªå…ˆé¸æ“‡ä¸­æ–‡ï¼‰
                      priority_langs = ['zh-Hant', 'zh-Hans', 'zh', 'en']
                      selected_file = None
                      
                      for lang in priority_langs:
                          for file in subtitle_files:
                              if lang in file:
                                  selected_file = file
                                  break
                          if selected_file:
                              break
                      
                      if not selected_file:
                          selected_file = subtitle_files[0]
                      
                      # è®€å–ä¸¦æ¸…ç†å­—å¹•
                      with open(selected_file, 'r', encoding='utf-8') as f:
                          transcript_raw = f.read()
                      
                      # æ¸…ç†å­—å¹•æ ¼å¼
                      transcript = self._clean_transcript(transcript_raw)
                      
                      return transcript, selected_file
                  
                  return "", None

              def _clean_transcript(self, transcript_raw):
                  """æ¸…ç†å­—å¹•æ–‡æœ¬"""
                  # ç§»é™¤ WEBVTT æ¨™é ­
                  transcript = re.sub(r'WEBVTT\r?\n\r?\n', '', transcript_raw)
                  
                  # ç§»é™¤æ™‚é–“æˆ³
                  transcript = re.sub(r'\d{2}:\d{2}:\d{2}[.,]\d{3}\s*-->\s*\d{2}:\d{2}:\d{2}[.,]\d{3}\r?\n', '', transcript)
                  
                  # ç§»é™¤ SRT åºè™Ÿ
                  transcript = re.sub(r'^\d+\r?\n', '', transcript, flags=re.MULTILINE)
                  
                  # ç§»é™¤ HTML æ¨™ç±¤
                  transcript = re.sub(r'<[^>]+>', '', transcript)
                  
                  # åˆä½µå¤šé¤˜çš„æ›è¡Œå’Œç©ºæ ¼
                  transcript = re.sub(r'\n+', ' ', transcript)
                  transcript = ' '.join(transcript.split())
                  
                  return transcript

              def upload_to_r2(self, local_path, remote_path, content_type='application/octet-stream'):
                  """ä¸Šå‚³æª”æ¡ˆåˆ° Cloudflare R2"""
                  s3_client = boto3.client(
                      's3',
                      endpoint_url=f"https://{self.config['cf_account_id']}.r2.cloudflarestorage.com",
                      aws_access_key_id=self.config['cf_r2_access_key'],
                      aws_secret_access_key=self.config['cf_r2_secret_key'],
                      region_name='auto'
                  )
                  
                  # è¨ˆç®—æª”æ¡ˆ hashï¼ˆç”¨æ–¼å»é‡ï¼‰
                  file_hash = self._calculate_file_hash(local_path)
                  
                  extra_args = {
                      'ContentType': content_type,
                      'Metadata': {
                          'platform': self.config['platform'],
                          'user_name': self.config['user_name'],
                          'job_id': self.config['job_id'],
                          'file_hash': file_hash,
                          'upload_time': datetime.now().isoformat(),
                          'processed_by': 'github-actions-optimized-v3'
                      }
                  }
                  
                  # ä½¿ç”¨å¤šéƒ¨åˆ†ä¸Šå‚³è™•ç†å¤§æª”æ¡ˆ
                  file_size = os.path.getsize(local_path)
                  if file_size > 50 * 1024 * 1024:  # 50MB
                      config = boto3.s3.transfer.TransferConfig(
                          multipart_threshold=1024 * 25,  # 25MB
                          max_concurrency=10,
                          multipart_chunksize=1024 * 25,
                          use_threads=True
                      )
                      s3_client.upload_file(
                          local_path,
                          self.config['cf_r2_bucket'],
                          remote_path,
                          ExtraArgs=extra_args,
                          Config=config
                      )
                  else:
                      s3_client.upload_file(
                          local_path,
                          self.config['cf_r2_bucket'],
                          remote_path,
                          ExtraArgs=extra_args
                      )
                  
                  return file_hash

              def _calculate_file_hash(self, filepath, chunk_size=8192):
                  """è¨ˆç®—æª”æ¡ˆçš„ SHA256 hash"""
                  sha256 = hashlib.sha256()
                  with open(filepath, 'rb') as f:
                      while chunk := f.read(chunk_size):
                          sha256.update(chunk)
                  return sha256.hexdigest()

              def run(self):
                  """åŸ·è¡Œä¸»è¦è™•ç†æµç¨‹"""
                  logger.info(f"ğŸ¬ Starting video processing: {self.config['job_id']}")
                  logger.info(f"ğŸ“º Platform: {self.config['platform']}")
                  logger.info(f"ğŸ‘¤ User: {self.config['user_name']} (Chat ID: {self.config['chat_id']})")
                  
                  try:
                      # 1. ä¸‹è¼‰å½±ç‰‡
                      info = self.download_video()
                      
                      # 2. æ‰¾åˆ°ä¸‹è¼‰çš„æª”æ¡ˆ
                      video_files = glob.glob(f"{self.config['job_id']}.*")
                      video_files = [f for f in video_files if not f.endswith(('.vtt', '.srt', '.txt'))]
                      
                      if not video_files:
                          raise FileNotFoundError("No video file found after download")
                      
                      filename = video_files[0]
                      
                      # 3. è™•ç†å½±ç‰‡æª”æ¡ˆï¼ˆå¯èƒ½å£“ç¸®ï¼‰
                      filename, file_size = self.process_video_file(filename, info)
                      
                      # æå–å½±ç‰‡è³‡è¨Š
                      video_title = info.get('title', 'Unknown')
                      video_description = info.get('description', '')
                      video_duration = info.get('duration', 0)
                      video_thumbnail = info.get('thumbnail', '')
                      
                      logger.info(f"âœ… Processed: {filename} ({file_size / 1024 / 1024:.1f}MB)")
                      
                      # 4. è™•ç†å­—å¹•
                      transcript, subtitle_file = self.process_subtitles()
                      
                      # 5. AI åˆ†æï¼ˆç•°æ­¥åŸ·è¡Œï¼‰
                      logger.info("ğŸ¤– Analyzing content...")
                      ai_analysis = self.analyze_with_ai(video_title, video_description, transcript)
                      
                      # 6. ä¸¦è¡Œä¸Šå‚³åˆ° R2
                      logger.info("â˜ï¸ Uploading to Cloudflare R2...")
                      
                      # æº–å‚™ä¸Šå‚³ä»»å‹™
                      file_ext = filename.split('.')[-1]
                      remote_video_path = f"videos/{self.config['job_id']}.{file_ext}"
                      remote_subtitle_path = f"subtitles/{self.config['job_id']}.vtt" if subtitle_file else ""
                      
                      # ä¸¦è¡Œä¸Šå‚³
                      with ThreadPoolExecutor(max_workers=2) as executor:
                          futures = []
                          
                          # ä¸Šå‚³å½±ç‰‡
                          futures.append(
                              executor.submit(
                                  self.upload_to_r2,
                                  filename,
                                  remote_video_path,
                                  f'video/{file_ext}'
                              )
                          )
                          
                          # ä¸Šå‚³å­—å¹•ï¼ˆå¦‚æœæœ‰ï¼‰
                          if subtitle_file:
                              futures.append(
                                  executor.submit(
                                      self.upload_to_r2,
                                      subtitle_file,
                                      remote_subtitle_path,
                                      'text/vtt'
                                  )
                              )
                          
                          # ç­‰å¾…æ‰€æœ‰ä¸Šå‚³å®Œæˆ
                          for future in as_completed(futures):
                              try:
                                  future.result()
                              except Exception as e:
                                  logger.error(f"Upload failed: {e}")
                                  raise
                      
                      logger.info(f"âœ… Uploaded to: {remote_video_path}")
                      
                      # 7. æº–å‚™æˆåŠŸå›èª¿
                      processing_time = round(time.time() - self.start_time, 2)
                      
                      # ç”Ÿæˆå…¬é–‹ URLï¼ˆå¦‚æœé…ç½®äº†ï¼‰
                      public_url = ""
                      if self.config.get('cf_r2_public_domain'):
                          public_url = f"https://{self.config['cf_r2_public_domain']}/{remote_video_path}"
                      
                      success_payload = {
                          **self.base_payload,
                          'status': 'completed',
                          'video_title': video_title,
                          'video_thumbnail': video_thumbnail,
                          'file_path': remote_video_path,
                          'public_url': public_url,
                          'file_size_mb': round(file_size / 1024 / 1024, 2),
                          'video_duration': video_duration,
                          'processing_time': processing_time,
                          'transcript_file': remote_subtitle_path,
                          'subtitle_file': remote_subtitle_path,
                          'has_subtitles': bool(subtitle_file),
                          **ai_analysis
                      }
                      
                      # 8. ç™¼é€æˆåŠŸå›èª¿
                      self.send_callback(success_payload)
                      logger.info(f"ğŸ‰ Job {self.config['job_id']} completed in {processing_time}s!")
                      
                  except Exception as e:
                      processing_time = round(time.time() - self.start_time, 2)
                      error_msg = str(e)
                      
                      logger.error(f"âŒ Processing failed: {error_msg}")
                      
                      # ç™¼é€éŒ¯èª¤å›èª¿
                      error_payload = {
                          **self.base_payload,
                          'status': 'error',
                          'error_message': error_msg,
                          'error_type': type(e).__name__,
                          'processing_time': processing_time
                      }
                      
                      try:
                          self.send_callback(error_payload)
                      except:
                          logger.error("âŒ Failed to send error callback")
                      
                      sys.exit(1)
                      
                  finally:
                      # æ¸…ç†è‡¨æ™‚æ–‡ä»¶
                      self._cleanup()

              def _cleanup(self):
                  """æ¸…ç†è‡¨æ™‚æ–‡ä»¶"""
                  patterns = [
                      f"{self.config['job_id']}*",
                      "cookies.txt",
                      "*.part",
                      "*.ytdl",
                      "*.temp"
                  ]
                  
                  for pattern in patterns:
                      for temp_file in glob.glob(pattern):
                          try:
                              os.remove(temp_file)
                              logger.debug(f"ğŸ—‘ï¸ Removed: {temp_file}")
                          except Exception as e:
                              logger.warning(f"âš ï¸ Failed to remove {temp_file}: {e}")

          def main():
              # ç²å–ç’°å¢ƒè®Šæ•¸
              config = {
                  'job_id': os.getenv('JOB_ID'),
                  'video_url': os.getenv('VIDEO_URL'),
                  'callback_url': os.getenv('CALLBACK_URL'),
                  'platform': os.getenv('PLATFORM', 'youtube').lower(),
                  'user_name': os.getenv('USER_NAME', 'Unknown'),
                  'chat_id': os.getenv('CHAT_ID', 'Unknown'),
                  'cf_account_id': os.getenv('CF_ACCOUNT_ID'),
                  'cf_r2_access_key': os.getenv('CF_R2_ACCESS_KEY'),
                  'cf_r2_secret_key': os.getenv('CF_R2_SECRET_KEY'),
                  'cf_r2_bucket': os.getenv('CF_R2_BUCKET'),
                  'cf_r2_public_domain': os.getenv('CF_R2_PUBLIC_DOMAIN'),
                  'openai_api_key': os.getenv('OPENAI_API_KEY'),
                  'default_chat_id': os.getenv('DEFAULT_CHAT_ID', 'system'),
              }
              
              # é©—è­‰å¿…è¦åƒæ•¸
              required_fields = ['job_id', 'video_url', 'cf_account_id', 'cf_r2_access_key', 
                               'cf_r2_secret_key', 'cf_r2_bucket']
              
              missing_fields = [field for field in required_fields if not config.get(field)]
              if missing_fields:
                  logger.error(f"âŒ Missing required fields: {missing_fields}")
                  sys.exit(1)
              
              # åŸ·è¡Œè™•ç†
              processor = VideoProcessor(config)
              processor.run()

          if __name__ == "__main__":
              main()
          EOF
          fi

      - name: ğŸ—‘ï¸ Cleanup
        if: always()
        run: |
          # æ¸…ç†æ‰€æœ‰è‡¨æ™‚æ–‡ä»¶
          rm -f cookies.txt
          rm -f ${{ env.JOB_ID }}*
          rm -f *.part *.ytdl *.temp
          
          # æ¸…ç† pip å¿«å–ï¼ˆæ¸›å°‘å„²å­˜ç©ºé–“ï¼‰
          pip cache purge || true

      - name: ğŸ“Š Job Summary
        if: always()
        run: |
          echo "## ğŸ¬ Video Processing Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # åŸºæœ¬è³‡è¨Šè¡¨æ ¼
          echo "### ğŸ“‹ åŸºæœ¬è³‡è¨Š" >> $GITHUB_STEP_SUMMARY
          echo "| Key | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---|---|" >> $GITHUB_STEP_SUMMARY
          echo "| **Job ID** | \`${{ env.JOB_ID }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| **Platform** | ${{ env.PLATFORM }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **User** | ${{ env.USER_NAME }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Status** | ${{ job.status == 'success' && 'âœ… Success' || 'âŒ Failed' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Run ID** | ${{ github.run_id }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Timestamp** | $(date -u '+%Y-%m-%d %H:%M:%S UTC') |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # è™•ç†è©³æƒ…
          if [ "${{ job.status }}" = "success" ]; then
            echo "### âœ… è™•ç†æˆåŠŸ" >> $GITHUB_STEP_SUMMARY
            echo "å½±ç‰‡å·²æˆåŠŸä¸‹è¼‰ã€åˆ†æä¸¦ä¸Šå‚³åˆ° Cloudflare R2ã€‚" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ è™•ç†å¤±æ•—" >> $GITHUB_STEP_SUMMARY
            echo "è«‹æª¢æŸ¥ä¸Šæ–¹çš„éŒ¯èª¤æ—¥èªŒä»¥ç­è§£è©³æƒ…ã€‚" >> $GITHUB_STEP_SUMMARY
          fi
          
          # å½±ç‰‡é€£çµ
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ”— ç›¸é—œé€£çµ" >> $GITHUB_STEP_SUMMARY
          echo "- [åŸå§‹å½±ç‰‡](${{ env.VIDEO_URL }})" >> $GITHUB_STEP_SUMMARY
          echo "- [æŸ¥çœ‹å·¥ä½œæµç¨‹é‹è¡Œ](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
